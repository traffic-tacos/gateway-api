# Reservation Worker 역할 명확화

## 🎯 전체 아키텍처 흐름

```
┌─────────────────────────────────────────────────────────────────┐
│                    30k RPS Traffic Incoming                      │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  Layer 1: Gateway API (입장 제어)                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ Redis Queue (Join/Status/Enter)                          │   │
│  │ • Token Bucket (RPS 제어)                                │   │
│  │ • Heartbeat (자동 이탈)                                  │   │
│  │ • ETA 계산 (Sliding Window)                              │   │
│  └──────────────────────────────────────────────────────────┘   │
│  Output: 30k RPS → 1k RPS (평탄화) ✅                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│               Layer 2: Reservation API (예약 관리)                │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ 예약 생성 (HOLD 상태, 60s TTL)                           │   │
│  │ → DynamoDB에 저장                                        │   │
│  │ → EventBridge Scheduler 등록 (60s 만료 타이머)           │   │
│  │ → SQS에 이벤트 발행 (Outbox 패턴)                        │   │
│  └──────────────────────────────────────────────────────────┘   │
│  Output: 이벤트 발행 → SQS 버퍼 ✅                                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                Layer 3: Message Queue (버퍼)                     │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ SQS FIFO Queue                                           │   │
│  │ • reservation.hold.expired                               │   │
│  │ • payment.approved                                       │   │
│  │ • payment.failed                                         │   │
│  │                                                          │   │
│  │ Queue Depth: 0-10,000+ (버퍼 역할) 🔥                    │   │
│  └──────────────────────────────────────────────────────────┘   │
│  Output: 순서화된 이벤트 → Worker ✅                              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│         Layer 4: Reservation Worker (쓰기 절연) 🔥               │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ KEDA 기반 오토스케일 (큐 깊이에 따라)                    │   │
│  │ • 큐 깊이 < 100: 1 Pod                                   │   │
│  │ • 큐 깊이 100-1000: 2-10 Pods                            │   │
│  │ • 큐 깊이 > 1000: 10-50 Pods                             │   │
│  │                                                          │   │
│  │ 이벤트 처리:                                             │   │
│  │ 1. reservation.hold.expired                              │   │
│  │    → Inventory API: ReleaseHold (gRPC)                  │   │
│  │    → Reservation API: EXPIRED (REST PATCH)              │   │
│  │                                                          │   │
│  │ 2. payment.approved                                      │   │
│  │    → Inventory API: CommitReservation (gRPC)            │   │
│  │    → Reservation API: CONFIRMED (REST PATCH)            │   │
│  │                                                          │   │
│  │ 3. payment.failed                                        │   │
│  │    → Inventory API: ReleaseHold (gRPC)                  │   │
│  │    → Reservation API: CANCELLED (REST PATCH)            │   │
│  │                                                          │   │
│  │ 멱등성: 동일 이벤트 중복 처리 방지 (DLQ 지원)            │   │
│  └──────────────────────────────────────────────────────────┘   │
│  Output: 제어된 DB 쓰기 (500-1,500 RPS) ✅                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│              Layer 5: Inventory API (재고 관리)                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ DynamoDB 조건부 업데이트 (원자적 갱신)                   │   │
│  │ • CommitReservation: HOLD → SOLD                         │   │
│  │ • ReleaseHold: HOLD → AVAILABLE                          │   │
│  │                                                          │   │
│  │ Zero Oversell 보장 ✅                                     │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## 🔥 핵심: 2단계 압력 제어

```
┌──────────────────────────────────────────────────────────────┐
│         Gateway API (앞단 압력 제어)                          │
│                                                              │
│  30,000 RPS (유입)                                           │
│      ↓                                                       │
│  Token Bucket + Redis Queue                                 │
│      ↓                                                       │
│  1,000 RPS (평탄화) ← 사용자 경험 유지 (토큰 즉시 발급)      │
└──────────────────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────────┐
│       Reservation Worker (뒷단 압력 제어) 🔥                 │
│                                                              │
│  1,000 RPS (예약 이벤트)                                     │
│      ↓                                                       │
│  SQS 버퍼 (큐 깊이 기반 스케일링)                            │
│      ↓                                                       │
│  500-1,500 RPS (DB 쓰기) ← DB 병목 방지                      │
└──────────────────────────────────────────────────────────────┘
```

## ❌ Worker 없이 직접 처리하면?

```
User (30k RPS)
   ↓
Gateway (1k RPS 평탄화)
   ↓
Reservation API (직접 처리)
   ↓ ← 🔥 병목 발생!
Inventory API (동시 요청 폭주)
   ↓ ← 💥 DB Lock Contention
DynamoDB (쓰기 한계 도달)
   ↓
❌ 오버셀 발생
❌ 타임아웃 증가
❌ 30k RPS 목표 실패
```

## ✅ Worker 있으면?

```
User (30k RPS)
   ↓
Gateway (1k RPS 평탄화)
   ↓
Reservation API (이벤트 발행만)
   ↓
SQS (버퍼, 순서화)
   ↓
Worker (KEDA 오토스케일)
   ↓ ← 🔥 제어된 흐름!
Inventory API (순서화된 요청)
   ↓ ← ✅ 락 충돌 최소화
DynamoDB (안정적 쓰기)
   ↓
✅ Zero Oversell
✅ P95 < 500ms
✅ 30k RPS 목표 달성
```

## 📊 Worker의 핵심 가치

1. **장애 격리**
   - Worker 장애 → 큐에 쌓임 (나중에 처리)
   - Inventory 장애 → DLQ로 이동 (수동 복구)
   - Reservation API는 계속 서비스 가능 ✅

2. **독립 스케일링**
   - KEDA가 큐 깊이 모니터링
   - 자동으로 Worker Pod 증감
   - 비용 최적화 (평상시 1 Pod, 피크 시 50 Pods)

3. **멱등성 보장**
   - 동일 이벤트 중복 처리 방지
   - SQS Deduplication ID
   - DynamoDB 조건부 업데이트

4. **재시도 전략**
   - 실패 시 자동 재시도 (3회)
   - DLQ로 이동 → 수동 복구
   - 전체 시스템 영향 최소화

5. **순서 보장**
   - SQS FIFO Queue
   - 동일 사용자의 이벤트 순서 유지
   - 동시성 충돌 방지

## 🎯 결론

**Gateway API ≠ Reservation Worker**

- Gateway: 입장 제어 (사용자 경험)
- Worker: 쓰기 절연 (시스템 안정성)

**둘 다 필요합니다!**

Worker 없이는 30k RPS 목표를 달성할 수 없습니다.
